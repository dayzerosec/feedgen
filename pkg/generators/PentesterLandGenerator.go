package generators

import (
	"encoding/json"
	"fmt"
	"github.com/gorilla/feeds"
	"io/ioutil"
	"net/http"
	"strings"
	"time"
)

type PentesterLandGenerator struct {
	filterFunc  ItemFilterFunc
	itemModFunc ItemModifierFunc
	MaxLength   int
}

type PentesterLandEntry struct {
	Links []struct {
		Title string
		Link  string
	}
	Authors         []string
	Programs        []string
	Bugs            []string
	Bounty          string
	PublicationDate string
	AddedDate       string
}

func (g *PentesterLandGenerator) fetch() ([]PentesterLandEntry, error) {
	url := "https://pentester.land/writeups.json"
	client := http.Client{
		Timeout: 15 * time.Second,
	}

	res, err := client.Get(url)
	if err != nil {
		return nil, err
	}
	defer func() { _ = res.Body.Close() }()

	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}

	var entries struct {
		Data []PentesterLandEntry `json:"data"`
	}

	err = json.Unmarshal(body, &entries)
	if err != nil {
		return nil, err
	}
	return entries.Data, nil
}

func (g *PentesterLandGenerator) Feed() (*feeds.Feed, error) {
	entries, err := g.fetch()
	if err != nil {
		return nil, err
	}

	out := feeds.Feed{}
	out.Title = "Pentester.Land Writeups"
	out.Link = &feeds.Link{Href: "https://pentester.land/writeups/"}
	out.Updated = time.Now()

	for _, e := range entries {
		item := &feeds.Item{
			Title: e.Links[0].Title,
			Link: &feeds.Link{
				Href: e.Links[0].Link,
			},
			Author: &feeds.Author{
				Name: strings.Join(e.Authors, ", "),
			},
			Description: strings.Join(e.Bugs, ", "),
			Updated:     time.Time{},
			Created:     time.Time{},
		}

		if e.Bounty != "-" && e.Bounty != "" {
			item.Description += fmt.Sprintf("(%s Bounty)", e.Bounty)
		}

		t, err := time.Parse("2006-01-02", e.PublicationDate)
		if err != nil {
			continue
		}
		item.Created = t

		t, err = time.Parse("2006-01-02", e.AddedDate)
		if err != nil {
			continue
		}
		item.Updated = t

		if g.itemModFunc != nil {
			g.itemModFunc(item)
		}
		if g.filterFunc == nil || g.filterFunc(item) {
			out.Items = append(out.Items, item)
		}

		if len(out.Items) >= g.MaxLength {
			break
		}
	}
	if len(out.Items) > 0 {
		out.Updated = out.Items[0].Updated
	}

	return &out, nil
}

func (g *PentesterLandGenerator) RegisterItemFilter(callback ItemFilterFunc) {
	g.filterFunc = callback
}
func (g *PentesterLandGenerator) RegisterItemModifier(callback ItemModifierFunc) {
	g.itemModFunc = callback
}
